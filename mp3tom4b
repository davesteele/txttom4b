#!/usr/bin/python3

import sys
import json
import argparse
import textwrap
import tempfile
import shutil
import subprocess
import shlex
from mutagen.mp3 import MP3

from os import access, R_OK
from os.path import isfile


class Book():
    def __init__(self, jsonPath=None):
        for tag in ['title', 'coverPath', 'year', 'author']:
            setattr(self, tag, "")
        self.chapterList = []

        if jsonPath:
            _LoadJson(jsonPath)

    def _LoadJson(self, jsonPath):
        jsonDict = json.loads(jsonPath)

        [setattr(self, x, jsonDict[x]) for x in jsonDict if x != "chapters"]
        self.chapterList = [Chapter(chap) for chap in jsonDict["chapters"]]

    def _SetAttrib(self, tag, value):
        if not getattr(self, tag):
            setattr(self, tag, value)

    def AddChapterMp3(self, path):
        chapter = Chapter(mp3Path=path)
        self.chapterList.append(chapter)

        self._SetAttrib('title', chapter.BookTitle())
        self._SetAttrib('author', chapter.Author())
        self._SetAttrib('year', chapter.Year())

        if not chapter.title:
            chapter.title = "Chapter {}".format(len(self.chapterList))

    def ToJson(self):
        outDict = vars(self).copy()
        del outDict["chapterList"]

        outDict["chapters"] = [vars(x) for x in self.chapterList]

        return json.dumps(outDict, indent=2)

    def Convert(self, outputFile="book.m4a"):

        morph = AudioManip()

        aacList = [morph.Mp3ToAac(x.mp3Path) for x in self.chapterList]

        morph.ConcatAac(outputFile, aacList)



class Chapter():
    def __init__(self, **kwargs):
        for tag in ['mp3Path']:
            setattr(self, tag, "")

        for arg in kwargs:
            setattr(self, arg, kwargs[arg])

        mp3 = MP3(self.mp3Path)
        self.duration = mp3.info.length
        self.title = self._GetTag('TIT2')

    def _GetTag(self, tag):
        mp3 = MP3(self.mp3Path)

        try:
            val = mp3[tag].text[0]
        except KeyError:
            val = ""

        return val

    def BookTitle(self):
        return self._GetTag('TALB')

    def Author(self):
        return self._GetTag('TPE1')

    def Year(self):
        return self._GetTag('TORY')


class AudioManip():
    def __init__(self):
        self.tmpdir = tempfile.mkdtemp()

    def __del__(self):
        shutil.rmtree(self.tmpdir)

    def Mp3ToAac(self, mp3Path):
        aacPath = tempfile.mktemp(suffix=".aac", dir=self.tmpdir)

        cmd = "ffmpeg -i \"{0}\" \"{1}\"".format(mp3Path, aacPath)
        subprocess.check_output(shlex.split(cmd))

        return aacPath

    def ConcatAac(self, outputFile, inputFiles):
        fileList = "|".join(inputFiles)
        cmd = "ffmpeg -i \"concat:{0}\" -c copy \"{1}\"".format(fileList, outputFile)
        subprocess.check_output(shlex.split(cmd))



def parseArgs():
    parser = argparse.ArgumentParser(
        description="Convert mp3 audio files to an m4b audiobook",
        epilog=textwrap.dedent("""
            When called with an argument list of mp3 files, %(prog)s will
            create a JSON file containing metadata for the collection.

            Edit the JSON file to refine meta information for the audiobook.

            When called with a single argument, %(prog)s will interpret the
            argument as a JSON metadata file, and will use it to create an
            m4b audio file containing the mp3 file and metadata information.
            """)[1:-1],
        usage="%(prog)s [-h] [<MP3 file> <MP3 file> [...] | <JSON file>]",
        formatter_class=argparse.RawDescriptionHelpFormatter,
    )

    parser.add_argument(
        "files",
        nargs="+",
        help=argparse.SUPPRESS,
    )

    args = parser.parse_args()

    for fpath in args.files:
        if not isfile(fpath) or not access(fpath, R_OK):
            parser.print_usage()
            print("{0}: error: {1} not readable".format(sys.argv[0], fpath))
            sys.exit(1)

    if len(args.files) > 1:
        args.mp3_files = args.files
        args.json_file = None
    else:
        args.mp3_files = []
        args.json_file = args.files[0]

    return args


def check_file(parser, path):
    if not isfile(path) or not access(path, R_OK):

        parser.print_usage()
        print("{0}: error: {1} not readable".format(sys.argv[0], path))
        sys.exit(1)


def main():

    args = parseArgs()

    
    if args.mp3_files:
        book = Book()

        for file in args.mp3_files:
            book.AddChapterMp3(file)

        print(book.ToJson())

        book.Convert()


if __name__ == "__main__":
    main()
